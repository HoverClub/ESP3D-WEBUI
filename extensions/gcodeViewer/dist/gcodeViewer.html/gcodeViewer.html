<script>const gcodeView_version="1.0.0";let gl;const programGridInfo={},programGCodeInfo={};let file,mvMatrix=createIdentityMatrix(),pMatrix=createIdentityMatrix(),animationFrameId=null,autoRotationSpeed=1e-4,lastFrameTime=0,gcodePoints=[],visiblePoints=[],fileReader=new FileReader,chunkSize=8192,fileOffset=0,totalFileSize=0,processedSize=0,lastPosition={x:0,y:0,z:0,e:0},gcodeMinX=1/0,gcodeMaxX=-1/0,gcodeMinY=1/0,gcodeMaxY=-1/0,gcodeMinZ=1/0,gcodeMaxZ=-1/0,gcode_vertices=[],gcode_colors=[],gcode_normals=[],layers=new Set,currentLayer=-1,lastSignificantZ=-1/0;const lineWidths={extrude:.4,move:.1,retract:.1},MAX_VERTICES=1e6;let isFileProcessing=!1,isComputing=!1,lastLayerZ=null,layerHeightSum=0,layerCount=0,printStarted=!1;const firstLayerMaxHeight=1,minLayerHeight=.05;let verticesPerLayer,currentZoom=1,averageLayerHeight=0,showNonExtrusionMoves=!1,startLayer=0,endLayer=1/0,invertXY=!1,invertFrontBack=!1,isSmartZoomEnabled=!1,isWheelInverted=!1,gridSide=200;const gridStep=10;let scaleFactor=1;const initialCameraDistance=500,minZoom=.1,maxZoom=15,LAYER_OPTIMIZATION_THRESHOLD=200;let startPanX,startPanY,rotation=[0,0],rotationCenter=[gridSide/2,gridSide/2,gridSide/2],cameraPosition=[0,0,initialCameraDistance],upVector=[0,1,0],totalRotation=[0,0],currentCameraDistance=initialCameraDistance,mouseDown=!1,lastMouseX=0,lastMouseY=0,isPanning=!1,lastPinchDistance=0;function vec3_cross(e,r){return[e[1]*r[2]-e[2]*r[1],e[2]*r[0]-e[0]*r[2],e[0]*r[1]-e[1]*r[0]]}function vec3_normalize(e){let r=Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);return[e[0]/r,e[1]/r,e[2]/r]}function createRotationMatrix(e,r){let t=Math.cos(e),o=Math.sin(e),a=1-t,[i,n,s]=r,l=a*i,c=a*n;return[l*i+t,l*n-o*s,l*s+o*n,0,l*n+o*s,c*n+t,c*s-o*i,0,l*s-o*n,c*s+o*i,a*s*s+t,0,0,0,0,1]}function createTranslationMatrix(e,r,t){return[1,0,0,0,0,1,0,0,0,0,1,0,e,r,t,1]}function createIdentityMatrix(){return[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}function multiplyMatrices(e,r){let t=createIdentityMatrix();for(let o=0;o<4;o++)for(let a=0;a<4;a++)t[4*o+a]=e[4*o+0]*r[0+a]+e[4*o+1]*r[4+a]+e[4*o+2]*r[8+a]+e[4*o+3]*r[12+a];return t}function perspectiveMatrix(e,r,t,o){let a=Math.tan(.5*Math.PI-.5*e),i=1/(t-o);return[a/r,0,0,0,0,a,0,0,0,0,(t+o)*i,-1,0,0,t*o*i*2,0]}function invertMatrix(e){let r,t=new Array(16);if(t[0]=e[5]*e[10]*e[15]-e[5]*e[11]*e[14]-e[9]*e[6]*e[15]+e[9]*e[7]*e[14]+e[13]*e[6]*e[11]-e[13]*e[7]*e[10],t[4]=-e[4]*e[10]*e[15]+e[4]*e[11]*e[14]+e[8]*e[6]*e[15]-e[8]*e[7]*e[14]-e[12]*e[6]*e[11]+e[12]*e[7]*e[10],t[8]=e[4]*e[9]*e[15]-e[4]*e[11]*e[13]-e[8]*e[5]*e[15]+e[8]*e[7]*e[13]+e[12]*e[5]*e[11]-e[12]*e[7]*e[9],t[12]=-e[4]*e[9]*e[14]+e[4]*e[10]*e[13]+e[8]*e[5]*e[14]-e[8]*e[6]*e[13]-e[12]*e[5]*e[10]+e[12]*e[6]*e[9],r=e[0]*t[0]+e[1]*t[4]+e[2]*t[8]+e[3]*t[12],0==r)return!1;r=1/r;for(let e=0;e<16;e++)t[e]*=r;return t}function multiplyMatrixAndPoint(e,r){const t=new Array(4);for(let o=0;o<4;o++){t[o]=0;for(let a=0;a<4;a++)t[o]+=e[4*o+a]*r[a]}return t}const viewMatrices={front:{normal:applyZoomToView([0,0,1,0,0,1,0,0,-1,0,0,0,0,0,-initialCameraDistance,1],1),inverted:applyZoomToView([1,0,0,0,0,1,0,0,0,0,1,0,0,0,-initialCameraDistance,1],1)},back:{normal:applyZoomToView([0,0,-1,0,0,1,0,0,1,0,0,0,0,0,initialCameraDistance,1],1),inverted:applyZoomToView([-1,0,0,0,0,1,0,0,0,0,-1,0,0,0,initialCameraDistance,1],1)},right:{normal:applyZoomToView([-1,0,0,0,0,1,0,0,0,0,-1,0,initialCameraDistance,0,0,1],1),inverted:applyZoomToView([0,0,-1,0,0,1,0,0,1,0,0,0,0,0,-initialCameraDistance,1],1)},left:{normal:applyZoomToView([1,0,0,0,0,1,0,0,0,0,1,0,-initialCameraDistance,0,0,1],1),inverted:applyZoomToView([0,0,1,0,0,1,0,0,-1,0,0,0,0,0,-initialCameraDistance,1],1)},bottom:{normal:applyZoomToView([0,1,0,0,0,0,-1,0,-1,0,0,0,0,0,initialCameraDistance,1],1),inverted:applyZoomToView([1,0,0,0,0,0,-1,0,0,1,0,0,0,initialCameraDistance,0,1],1)},top:{normal:applyZoomToView([0,-1,0,0,0,0,1,0,-1,0,0,0,0,0,-initialCameraDistance,1],1),inverted:applyZoomToView([1,0,0,0,0,0,1,0,0,-1,0,0,0,-initialCameraDistance,0,1],1)}};function applyZoomToView(e,r){let t=e.slice(),o=t[12],a=t[13],i=t[14],n=gridSide/2,s=gridSide/2,l=gridSide/2;for(let e=0;e<12;e++)t[e]*=r;return t[12]=n+(o-n)*r,t[13]=s+(a-s)*r,t[14]=l+(i-l)*r,t}function setView(e){currentCameraDistance=initialCameraDistance,currentZoom=1,scaleFactor=1;let r=e.toLowerCase();if(invertFrontBack)switch(r){case"front":r="back";break;case"back":r="front";break;case"right":r="left";break;case"left":r="right"}mvMatrix=viewMatrices[r][invertXY?"inverted":"normal"].slice(),totalRotation=[0,0];let t=createTranslationMatrix(-gridSide/2,-gridSide/2,-gridSide/2);if(mvMatrix=multiplyMatrices(mvMatrix,t),invertXY)switch(r){case"back":mvMatrix[14]=-currentCameraDistance+gridSide,mvMatrix[12]+=gridSide;break;case"left":mvMatrix[14]=-currentCameraDistance,mvMatrix[12]+=gridSide;break;case"right":mvMatrix[14]=-currentCameraDistance+gridSide;break;case"top":mvMatrix[13]=gridSide/2,mvMatrix[14]=-currentCameraDistance;break;case"bottom":mvMatrix[13]=-gridSide/2,mvMatrix[14]=-currentCameraDistance+gridSide;break;default:mvMatrix[14]=-currentCameraDistance}else switch(r){case"back":mvMatrix[14]=-currentCameraDistance+gridSide;break;case"left":mvMatrix[12]=-gridSide/2,mvMatrix[14]=-currentCameraDistance;break;case"right":mvMatrix[12]=gridSide/2,mvMatrix[14]=-currentCameraDistance+gridSide;break;case"top":mvMatrix[12]=gridSide/2,mvMatrix[13]=gridSide/2,mvMatrix[14]=-currentCameraDistance;break;case"bottom":mvMatrix[12]=gridSide/2,mvMatrix[13]=-gridSide/2,mvMatrix[14]=-currentCameraDistance+gridSide;break;default:mvMatrix[12]=gridSide/2,mvMatrix[14]=-currentCameraDistance}cameraPosition=[mvMatrix[12],mvMatrix[13],mvMatrix[14]],upVector=[mvMatrix[1],mvMatrix[5],mvMatrix[9]],currentCameraDistance=Math.sqrt(cameraPosition[0]*cameraPosition[0]+cameraPosition[1]*cameraPosition[1]+cameraPosition[2]*cameraPosition[2])}function checkBufferStatus(e,r,t=gl.ARRAY_BUFFER_BINDING){return!!e&&(!checkGLError()&&gl.getParameter(t)==e)}function checkGLError(e=null){const r=gl.getError();return r!==gl.NO_ERROR&&(console.error(`Error in WebGL ${e||""}:`,r),!0)}function checkglStatus(){return gl?gl.isContextLost()?(console.error("WebGL context is lost"),!1):!checkGLError():(console.error("WebGL is not initialized"),!1)}function checkProgramStatus(e,r){return e?(gl.validateProgram(e),gl.getProgramParameter(e,gl.VALIDATE_STATUS)?!!gl.getProgramParameter(e,gl.LINK_STATUS)||(console.error("Shader program ${name} failed to link:",gl.getProgramInfoLog(e)),!1):(console.error("Validation error for shader program:",gl.getProgramInfoLog(e)),!1)):(console.error("Shader program ${name} is null"),!1)}function checkAttribut(e,r){return-1!==e||(console.error("Impossible to locate the attribute ",r),!1)}function checkUniform(e,r){return!(!e||-1===e)||(console.error("Impossible to locate the uniform ",r),!1)}function checkShader(e,r){return e?!!gl.getShaderParameter(e,gl.COMPILE_STATUS)||(console.error(`Error compiling shader ${r}:`,gl.getShaderInfoLog(e)),gl.deleteShader(e),!1):(console.error(`Shader ${r} is null`),!1)}function enableAttributes(e){e.attribLocations&&Object.values(e.attribLocations).forEach((e=>{gl.enableVertexAttribArray(e)}))}function disableAttributes(e){e.attribLocations&&Object.values(e.attribLocations).forEach((e=>{gl.disableVertexAttribArray(e)}))}function useProgram(e,r){gl.useProgram(e.program),disableAttributes(r),enableAttributes(e)}function initCamera(){cameraPosition=[0,0,initialCameraDistance],upVector=[0,1,0],totalRotation=[0,0]}function initWebGL(e){gl=e.getContext("webgl"),gl?(gl.clearColor(1,1,1,1),gl.enable(gl.DEPTH_TEST)):alert("Failed to initialize WebGL. Your browser may not support this feature.")}function debounce(e,r){let t;return function(...o){clearTimeout(t),t=setTimeout((()=>{clearTimeout(t),e(...o)}),r)}}async function updatePointsAndRedraw(){try{await updateVisiblePoints(!0),drawScene()}catch(e){console.error("Error updating visible points:",e)}}const debouncedUpdateAndRedraw=debounce(updatePointsAndRedraw,250);function getShader(e,r){const t=document.getElementById(r);if(!t)return console.error(`Shader script not found: ${r}`),null;const o=t.textContent.trim();if(!o)return console.error(`Shader content is empty: ${r}`),null;let a;if("x-shader/x-vertex"===t.type)a=e.createShader(e.VERTEX_SHADER);else{if("x-shader/x-fragment"!==t.type)return console.error(`Type de shader inconnu: ${t.type}`),null;a=e.createShader(e.FRAGMENT_SHADER)}return e.shaderSource(a,o),e.compileShader(a),checkShader(a,r)?a:null}function createShaderProgram(e,r,t,o){if(!checkShader(e,`${t} vertex shader`)||!checkShader(r,`${t} fragment shader`))return null;const a=gl.createProgram();return gl.attachShader(a,e),gl.attachShader(a,r),o.forEach(((e,r)=>{gl.bindAttribLocation(a,r,e)})),gl.linkProgram(a),gl.getProgramParameter(a,gl.LINK_STATUS)?a:(console.error(`Unable to initialize the shader program ${t}:`,gl.getProgramInfoLog(a)),null)}function createShaders(){return createGridShader()?!!createGCodeShader()||(console.error("Impossible to create the gcode shader"),!1):(console.error("Impossible to create the grid shader"),!1)}function createGridShader(){disableAttributes(programGCodeInfo);const e=getShader(gl,"grid-vertex-shader");if(!e)return!1;const r=getShader(gl,"fragment-shader-grid");return!!r&&(programGridInfo.program=createShaderProgram(e,r,"programGrid",["grid_aVertexPosition","grid_aVertexColor","grid_aVertexNormal"]),!!checkProgramStatus(programGridInfo.program,"programGrid")&&(programGridInfo.attribLocations={},programGridInfo.attribLocations.vertexPosition=gl.getAttribLocation(programGridInfo.program,"grid_aVertexPosition"),!!checkAttribut(programGridInfo.attribLocations.vertexPosition,"grid_aVertexPosition")&&(programGridInfo.attribLocations.vertexColor=gl.getAttribLocation(programGridInfo.program,"grid_aVertexColor"),!!checkAttribut(programGridInfo.attribLocations.vertexColor,"grid_aVertexColor")&&(programGridInfo.uniformLocations={},programGridInfo.uniformLocations.pMatrix=gl.getUniformLocation(programGridInfo.program,"grid_uPMatrix"),!!checkUniform(programGridInfo.uniformLocations.pMatrix,"grid_uPMatrix")&&(programGridInfo.uniformLocations.mvMatrix=gl.getUniformLocation(programGridInfo.program,"grid_uMVMatrix"),!!checkUniform(programGridInfo.uniformLocations.mvMatrix,"grid_uMVMatrix"))))))}function createGCodeShader(){disableAttributes(programGridInfo);const e=getShader(gl,"gcode-vertex-shader");if(!e)return console.error("Failed to get vertex shader"),!1;const r=getShader(gl,"fragment-shader-gcode");if(!r)return console.error("Failed to get fragment shader"),!1;const t=createShaderProgram(e,r,"programGCode",["gcode_aVertexPosition","gcode_aVertexColor","gcode_aVertexNormal"]);return t?!!checkProgramStatus(t,"programGCode")&&(programGCodeInfo.program=t,programGCodeInfo.attribLocations={},programGCodeInfo.attribLocations={vertexPosition:gl.getAttribLocation(t,"gcode_aVertexPosition"),vertexNormal:gl.getAttribLocation(t,"gcode_aVertexNormal"),vertexColor:gl.getAttribLocation(t,"gcode_aVertexColor")},programGCodeInfo.uniformLocations={pMatrix:gl.getUniformLocation(t,"gcode_uPMatrix"),mvMatrix:gl.getUniformLocation(t,"gcode_uMVMatrix"),lightPosition:gl.getUniformLocation(t,"gcode_uLightPosition"),ambientColor:gl.getUniformLocation(t,"gcode_uAmbientColor"),diffuseColor:gl.getUniformLocation(t,"gcode_uDiffuseColor")},!0):(console.error("Failed to create shader program"),!1)}function createGridBuffers(){if(disableAttributes(programGCodeInfo),gridSide=calculateGridSide(),0===gridSide||"NaN"==gridSide.toString())return console.error("Impossible to calculate the grid side. Please check your GCode file."),!1;const e=[],r=[];for(let t=0;t<=gridSide;t+=gridStep){e.push(0,0,t,gridSide,0,t),e.push(t,0,0,t,0,gridSide);for(let e=0;e<4;e++)r.push(.8,.8,.8,1)}if(programGridInfo.buffer=gl.createBuffer(),programGridInfo.buffer&&(gl.bindBuffer(gl.ARRAY_BUFFER,programGridInfo.buffer),gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(e),gl.STATIC_DRAW)),!checkBufferStatus(programGridInfo.buffer,"Grid buffer"))return!1;if(programGridInfo.buffer.itemSize=3,programGridInfo.buffer.numItems=e.length/3,programGridInfo.colorBuffer=gl.createBuffer(),programGridInfo.colorBuffer&&(gl.bindBuffer(gl.ARRAY_BUFFER,programGridInfo.colorBuffer),gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(r),gl.STATIC_DRAW)),!checkBufferStatus(programGridInfo.colorBuffer,"Grid color buffer"))return!1;const t=.5,o=[0,-.5,-.5,gridSide,-.5,-.5,0,t,-.5,gridSide,t,-.5,0,t,t,gridSide,t,t,0,-.5,t,gridSide,-.5,t,-.5,-.5,0,-.5,-.5,gridSide,t,-.5,0,t,-.5,gridSide,t,t,0,t,t,gridSide,-.5,t,0,-.5,t,gridSide,-.5,0,-.5,-.5,gridSide,-.5,t,0,-.5,t,gridSide,-.5,t,0,t,t,gridSide,t,-.5,0,t,-.5,gridSide,t],a=[];for(let e=0;e<8;e++)invertXY?a.push(1,0,0,1):a.push(0,1,0,1);for(let e=0;e<8;e++)invertXY?a.push(0,1,0,1):a.push(1,0,0,1);for(let e=0;e<8;e++)a.push(0,0,1,1);if(programGridInfo.axesBuffer=gl.createBuffer(),programGridInfo.axesBuffer&&(gl.bindBuffer(gl.ARRAY_BUFFER,programGridInfo.axesBuffer),gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(o),gl.STATIC_DRAW),programGridInfo.axesBuffer.itemSize=3,programGridInfo.axesBuffer.numItems=o.length/3),!checkBufferStatus(programGridInfo.axesBuffer,"Grid axes buffer"))return!1;if(programGridInfo.axesBuffer.itemSize=3,programGridInfo.axesBuffer.numItems=o.length/3,programGridInfo.axesColorBuffer=gl.createBuffer(),programGridInfo.axesColorBuffer&&(gl.bindBuffer(gl.ARRAY_BUFFER,programGridInfo.axesColorBuffer),gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(a),gl.STATIC_DRAW)),!checkBufferStatus(programGridInfo.axesColorBuffer,"Grid axes color buffer"))return!1;const i=[0,1,2,2,1,3,2,3,6,6,3,7,4,5,6,6,5,7,0,4,1,1,4,5,8,9,10,10,9,11,10,11,14,14,11,15,12,13,14,14,13,15,8,12,9,9,12,13,16,17,18,18,17,19,18,19,22,22,19,23,20,21,22,22,21,23,16,20,17,17,20,21];return programGridInfo.axesIndexBuffer=gl.createBuffer(),programGridInfo.axesIndexBuffer&&(gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,programGridInfo.axesIndexBuffer),gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(i),gl.STATIC_DRAW),programGridInfo.axesIndexBuffer.numItems=i.length),!!checkBufferStatus(programGridInfo.axesIndexBuffer,"Grid axes index buffer",gl.ELEMENT_ARRAY_BUFFER_BINDING)&&createAxisLabelsBuffers()}function updateAxisColors(){const e=[];for(let r=0;r<8;r++)e.push(invertXY?1:0,invertXY?0:1,0,1);for(let r=0;r<8;r++)e.push(invertXY?0:1,invertXY?1:0,0,1);for(let r=0;r<8;r++)e.push(0,0,1,1);gl.bindBuffer(gl.ARRAY_BUFFER,programGridInfo.axesColorBuffer),gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(e),gl.STATIC_DRAW)}function createAxisLabelsBuffers(){return!!createXLabelBuffer()&&(!!createYLabelBuffer()&&createZLabelBuffer())}function createLabelBuffer(e){const r=gl.createBuffer();return r&&(gl.bindBuffer(gl.ARRAY_BUFFER,r),gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(e),gl.STATIC_DRAW),r.itemSize=3,r.numItems=e.length/3),r}function createLabelColorBuffer(e){const r=new Array(6).fill(e).flat(),t=gl.createBuffer();return t&&(gl.bindBuffer(gl.ARRAY_BUFFER,t),gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(r),gl.STATIC_DRAW)),t}function createXLabelBuffer(){const e=.05*gridSide,r=gridSide+.05*gridSide/4,t=invertXY?.05*-gridSide/2:0,o=invertXY?0:.05*-gridSide,a=(invertXY?[[0,0,0],[e,e,0],[0,e,0],[e,0,0]]:[[0,0,e/2],[e/2,0,0],[e,0,e/2],[e/2,0,0],[e/2,0,0],[e/2,0,-e/2]]).flatMap((e=>invertXY?[e[0]+r,e[1]+t,e[2]+o]:[e[1]+r,e[2]+t,e[0]+o]));return programGridInfo.xLabelBuffer=createLabelBuffer(a),!!checkBufferStatus(programGridInfo.xLabelBuffer,"X Label Buffer")&&(programGridInfo.xLabelColorBuffer=createLabelColorBuffer(invertXY?[1,0,0,1]:[0,1,0,1]),!!checkBufferStatus(programGridInfo.xLabelColorBuffer,"X Label Color Buffer"))}function createYLabelBuffer(){const e=.05*gridSide,r=invertXY?-.05*gridSide:0,t=invertXY?0:.05*-gridSide/4,o=invertXY?gridSide+.06*gridSide/2:gridSide+.05*gridSide/2,a=(invertXY?[[0,0,e/2],[e/2,0,0],[e,0,e/2],[e/2,0,0],[e/2,0,0],[e/2,0,-e/2]]:[[0,0,0],[e,e,0],[0,e,0],[e,0,0]]).flatMap((e=>invertXY?[e[0]+r-10,e[2]+t,e[1]+o]:[e[2]+r,e[0]+t,e[1]+o]));return programGridInfo.yLabelBuffer=createLabelBuffer(a),!!checkBufferStatus(programGridInfo.yLabelBuffer,"Y Label Buffer")&&(programGridInfo.yLabelColorBuffer=createLabelColorBuffer(invertXY?[0,1,0,1]:[1,0,0,1],a.length/3),!!checkBufferStatus(programGridInfo.yLabelColorBuffer,"Y Label Color Buffer"))}function createZLabelBuffer(){const e=.05*gridSide,r=invertXY?.05*-gridSide/2:0,t=invertXY?gridSide+.07*gridSide:gridSide+.05*gridSide/2,o=invertXY?0:.05*-gridSide/2,a=(invertFrontBack?[[e,0,0],[0,0,0],[0,0,0],[e,0,e],[e,0,e],[0,0,e]]:[[0,0,0],[e,0,0],[e,0,0],[0,0,e],[0,0,e],[e,0,e]]).flatMap((e=>invertXY?[e[0]+r,-e[2]+t,e[1]+o]:[e[1]+r,e[2]+t,e[0]+o]));return programGridInfo.zLabelBuffer=createLabelBuffer(a),!!checkBufferStatus(programGridInfo.zLabelBuffer,"Z Label Buffer")&&(programGridInfo.zLabelColorBuffer=createLabelColorBuffer([0,0,1,1]),!!checkBufferStatus(programGridInfo.zLabelColorBuffer,"Z Label Color Buffer"))}function cleanupGCodeBuffers(){programGCodeInfo.buffers&&programGCodeInfo.buffers.forEach((e=>{gl.deleteBuffer(e.vertexBuffer),gl.deleteBuffer(e.colorBuffer),gl.deleteBuffer(e.normalBuffer)})),programGCodeInfo.buffers=[]}function drawScene(){return!!checkglStatus()&&(!!checkProgramStatus(programGridInfo.program,"programGrid")&&(useProgram(programGridInfo,programGCodeInfo),gl.viewport(0,0,gl.canvas.width,gl.canvas.height),gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT),pMatrix=perspectiveMatrix(45*Math.PI/180,gl.canvas.width/gl.canvas.height,.1,1e4),gl.uniformMatrix4fv(programGridInfo.uniformLocations.pMatrix,!1,new Float32Array(pMatrix)),!checkGLError("pMatrix")&&(gl.uniformMatrix4fv(programGridInfo.uniformLocations.mvMatrix,!1,new Float32Array(mvMatrix)),!checkGLError("mvMatrix")&&(!!drawGrid()&&(!!drawAxes()&&(!!drawAxisLabels()&&(gcodePoints.length>0?drawGCode():(isComputing=!1,updateProgress("",100),!0))))))))}function drawGrid(){return!!checkProgramStatus(programGridInfo.program,"programGrid")&&(gl.bindBuffer(gl.ARRAY_BUFFER,programGridInfo.buffer),gl.vertexAttribPointer(programGridInfo.attribLocations.vertexPosition,3,gl.FLOAT,!1,0,0),checkBufferStatus(programGridInfo.buffer,"Grid buffer"),!checkGLError("Grid buffer")&&(gl.bindBuffer(gl.ARRAY_BUFFER,programGridInfo.colorBuffer),gl.vertexAttribPointer(programGridInfo.attribLocations.vertexColor,4,gl.FLOAT,!1,0,0),!checkGLError("Grid color buffer")&&(checkBufferStatus(programGridInfo.colorBuffer,"Grid color buffer"),gl.drawArrays(gl.LINES,0,programGridInfo.buffer.numItems),!checkGLError("Draw grid"))))}function drawAxes(){return!!checkProgramStatus(programGridInfo.program,"programGrid")&&(gl.bindBuffer(gl.ARRAY_BUFFER,programGridInfo.axesBuffer),gl.vertexAttribPointer(programGridInfo.attribLocations.vertexPosition,3,gl.FLOAT,!1,0,0),!checkGLError("Axes buffer")&&(gl.bindBuffer(gl.ARRAY_BUFFER,programGridInfo.axesColorBuffer),gl.vertexAttribPointer(programGridInfo.attribLocations.vertexColor,4,gl.FLOAT,!1,0,0),!checkGLError("Axes color buffer")&&(gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,programGridInfo.axesIndexBuffer),gl.drawElements(gl.TRIANGLES,programGridInfo.axesIndexBuffer.numItems,gl.UNSIGNED_SHORT,0),!checkGLError("Draw axes"))))}function drawAxisLabels(){return!!drawLabel(programGridInfo.xLabelBuffer,programGridInfo.xLabelColorBuffer)&&(!!drawLabel(programGridInfo.yLabelBuffer,programGridInfo.yLabelColorBuffer)&&drawLabel(programGridInfo.zLabelBuffer,programGridInfo.zLabelColorBuffer))}function drawLabel(e,r,t){return!!checkProgramStatus(programGridInfo.program,"programGrid")&&(gl.bindBuffer(gl.ARRAY_BUFFER,e),gl.vertexAttribPointer(programGridInfo.attribLocations.vertexPosition,3,gl.FLOAT,!1,0,0),!checkGLError(`Axes buffer ${t}`)&&(gl.bindBuffer(gl.ARRAY_BUFFER,r),gl.vertexAttribPointer(programGridInfo.attribLocations.vertexColor,4,gl.FLOAT,!1,0,0),!checkGLError(`Axes color buffer ${t}`)&&(gl.drawArrays(gl.LINES,0,e.numItems),!checkGLError(`Draw label ${t}`))))}function loadGCodeFile(e){updateProgress("Initializing:",0),isFileProcessing=!0,startProcessing(e),processEntireFile()}async function finishProcessing(){document.getElementById("fileInput").value=null,updateProgress("Processing G-code:",90),createGridBuffers(),initLayerSliders(),await updateVisiblePoints(!1),updateProgress("Rendering:",100),isFileProcessing=!1,setView("front"),drawScene()}function readNextChunk(){return new Promise(((e,r)=>{if(fileOffset>=file.size)return void e("EOF");let t=file.slice(fileOffset,fileOffset+chunkSize);fileReader.onload=function(t){processChunk(t.target.result).then(e).catch(r)},fileReader.onerror=r,fileReader.readAsText(t)}))}async function processChunk(e){let r=e.split("\n");if(fileOffset>0){let e=gcodePoints[gcodePoints.length-1];r[0]=e.gcode+r[0],gcodePoints.pop()}for(let e=0;e<r.length-1;e++)processGCodeLine(r[e]);fileOffset+chunkSize<file.size?gcodePoints.push({gcode:r[r.length-1]}):processGCodeLine(r[r.length-1]),fileOffset+=chunkSize,updateProgress("Loading file:",fileOffset/file.size*90)}async function processEntireFile(){try{for(;;){if("EOF"===await readNextChunk())break}await finishProcessing()}catch(e){console.error("Error processing file:",e)}}function startProcessing(e){file=e,fileOffset=0,gcodePoints=[],gcodeMinX=gcodeMinY=gcodeMinZ=1/0,gcodeMaxX=gcodeMaxY=gcodeMaxZ=-1/0,lastLayerZ=null,layerHeightSum=0,layerCount=0,printStarted=!1,totalFileSize=e.size,processedSize=0,lastSignificantZ=-1/0,currentLayer=-1,lastPosition={x:0,y:0,z:0,e:0,layer:0}}function processGCodeLine(e){let r="move";if(processedSize+=e.length+1,e.trim().startsWith(";")||""===e.trim())return;if(!e.trim().startsWith("G0")&&!e.trim().startsWith("G1")&&!e.trim().startsWith("G28"))return;let t=null,o=null,a=null,i=null,n=e.split(" "),s=e.trim().startsWith("G0");if(e.trim().startsWith("G28")){r="move";for(let e of n){parseFloat(e.substring(1));switch(e[0]){case"X":t||(t=0);break;case"Y":o||(o=0);break;case"Z":a||(a=0)}}null==t&&null==o&&null==a&&(t=0,o=0,a=0)}else for(let e of n){let r=parseFloat(e.substring(1));if("NaN"!=r)switch(e[0]){case"X":t||(t=r);break;case"Y":o||(o=r);break;case"Z":a||(a=r);break;case"E":i||(i=r)}}null!==i&&(r=i>0?"extrude":"retract");let l={x:null!==t?t:lastPosition.x,y:null!==o?o:lastPosition.y,z:null!==a?a:lastPosition.z,e:null!==i?i:lastPosition.e};"extrude"===r&&(!printStarted&&l.z>0&&l.z<firstLayerMaxHeight?(printStarted=!0,lastLayerZ=l.z):printStarted&&Math.abs(l.z-lastLayerZ)>=minLayerHeight&&(layerHeightSum+=Math.abs(l.z-lastLayerZ),layerCount++,lastLayerZ=l.z)),l.z!==lastPosition.z&&Math.abs(l.z-lastSignificantZ)>.001&&(lastSignificantZ=l.z,currentLayer++,layers.add(currentLayer)),gcodeMinX=Math.min(gcodeMinX,l.x),gcodeMaxX=Math.max(gcodeMaxX,l.x),gcodeMinY=Math.min(gcodeMinY,l.y),gcodeMaxY=Math.max(gcodeMaxY,l.y),gcodeMinZ=Math.min(gcodeMinZ,l.z),gcodeMaxZ=Math.max(gcodeMaxZ,l.z),invertXY||(lastPosition.x==l.x&&(l.x+=1e-5),lastPosition.y==l.y&&(l.y+=1e-5));let c=transformGCodePoint(lastPosition),d=transformGCodePoint(l);if(null!==t||null!==o||null!==a){let e={x:d.x-c.x,y:d.y-c.y,z:d.z-c.z},t=Math.sqrt(e.x*e.x+e.y*e.y+e.z*e.z),o={x:e.x/t,y:e.y/t,z:e.z/t};gcodePoints.push({start:c,end:d,isG0:s,moveType:r,layer:currentLayer,normal:o})}lastPosition=l}function getAverageLayerHeight(){return layerCount>0?layerHeightSum/layerCount:0}function calculateGridSide(){if(0===gcodePoints.length)return 200;const e=gcodeMaxX-gcodeMinX+(gcodeMinX>0?gcodeMinX:0),r=gcodeMaxY-gcodeMinY+(gcodeMinY>0?gcodeMinY:0),t=gcodeMaxZ-gcodeMinZ+(gcodeMinZ>0?gcodeMinZ:0);let o=Math.max(e,r,t);return 10*Math.ceil(o/10)+10}const getSkipFactor=(e,r)=>1;function transformGCodePoint(e){return{x:e.y,y:e.z,z:e.x,e:e.e}}function getTransformedPoint(e){return invertXY?{x:e.z,y:e.y,z:e.x,e:e.e}:e}function roundToInteger(e){return e.map((e=>Math.round(127*e)))}async function updateVisiblePoints(e=!1){isComputing||(isComputing=!0,updateProgress("Processing G-code:",90),e&&programGCodeInfo.buffers&&0!==programGCodeInfo.buffers.length?createVisibleBuffer():await recalculateBuffers(),isComputing=!1,drawScene())}async function recalculateBuffers(){cleanupGCodeBuffers(),gcode_vertices=[],gcode_colors=[],gcode_normals=[],programGCodeInfo.buffers=[],visiblePoints=gcodePoints.filter((e=>(showNonExtrusionMoves||"extrude"===e.moveType)&&e.layer>=startLayer&&e.layer<=endLayer)).map((e=>({...e,start:getTransformedPoint(e.start),end:getTransformedPoint(e.end)})));const e=visiblePoints.length,r=Math.max(1,Math.floor(e/100));if(0===e)return;let t=0,o={vertices:[],colors:[],normals:[],firstLayer:1/0,lastLayer:-1/0};for(let a=0;a<visiblePoints.length;a++){const i=visiblePoints[a],n=lineWidths[i.moveType]||lineWidths.move,s={x:i.end.x-i.start.x,y:i.end.y-i.start.y,z:i.end.z-i.start.z},l=Math.sqrt(s.x**2+s.y**2+s.z**2),c={x:s.x/l,y:s.y/l,z:s.z/l};let d;d=Math.abs(c.y)<.99?vec3_normalize(vec3_cross([c.x,c.y,c.z],[0,1,0])):vec3_normalize(vec3_cross([c.x,c.y,c.z],[1,0,0]));const f=vec3_cross([c.x,c.y,c.z],d),g=8;for(let e=0;e<g;e++){const r=e/g*2*Math.PI,t=(e+1)/g*2*Math.PI,a=Math.cos(r),s=Math.sin(r),l=Math.cos(t),c=Math.sin(t),u={x:i.start.x+(d[0]*a+f[0]*s)*n/2,y:i.start.y+(d[1]*a+f[1]*s)*n/2,z:i.start.z+(d[2]*a+f[2]*s)*n/2},m={x:i.start.x+(d[0]*l+f[0]*c)*n/2,y:i.start.y+(d[1]*l+f[1]*c)*n/2,z:i.start.z+(d[2]*l+f[2]*c)*n/2},p={x:i.end.x+(d[0]*a+f[0]*s)*n/2,y:i.end.y+(d[1]*a+f[1]*s)*n/2,z:i.end.z+(d[2]*a+f[2]*s)*n/2},h={x:i.end.x+(d[0]*l+f[0]*c)*n/2,y:i.end.y+(d[1]*l+f[1]*c)*n/2,z:i.end.z+(d[2]*l+f[2]*c)*n/2};o.vertices.push(u.x,u.y,u.z,m.x,m.y,m.z,p.x,p.y,p.z,m.x,m.y,m.z,p.x,p.y,p.z,h.x,h.y,h.z);const x=roundToInteger(vec3_normalize([d[0]*a+f[0]*s,d[1]*a+f[1]*s,d[2]*a+f[2]*s])),v=roundToInteger(vec3_normalize([d[0]*l+f[0]*c,d[1]*l+f[1]*c,d[2]*l+f[2]*c]));let y;switch(o.normals.push(...x,...v,...x,...v,...x,...v),i.moveType){case"extrude":y=[0,1,1,1];break;case"retract":y=[1,0,0,1];break;default:y=[0,0,1,1]}for(let e=0;e<6;e++)o.colors.push(...y)}o.firstLayer=Math.min(o.firstLayer,i.layer),o.lastLayer=Math.max(o.lastLayer,i.layer),(o.vertices.length>=MAX_VERTICES||a===visiblePoints.length-1)&&(gcode_vertices.push(o.vertices),gcode_colors.push(o.colors),gcode_normals.push(o.normals),programGCodeInfo.buffers.push({firstLayer:o.firstLayer,lastLayer:o.lastLayer}),o={vertices:[],colors:[],normals:[],firstLayer:1/0,lastLayer:-1/0}),t++,t%r==0&&(updateProgress("Processing G-code:",Math.ceil(t/e*100)),await new Promise((e=>setTimeout(e,0))))}verticesPerLayer=Math.ceil(gcode_vertices.reduce(((e,r)=>e+r.length),0)/(endLayer-startLayer+1)),await createGCodeBuffers()}async function createGCodeBuffers(){for(let e=0;e<gcode_vertices.length;e++){const r=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,r),gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(gcode_vertices[e]),gl.STATIC_DRAW);const t=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,t),gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(gcode_colors[e]),gl.STATIC_DRAW);const o=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,o),gl.bufferData(gl.ARRAY_BUFFER,new Int8Array(gcode_normals[e]),gl.STATIC_DRAW),programGCodeInfo.buffers[e].vertexBuffer=r,programGCodeInfo.buffers[e].colorBuffer=t,programGCodeInfo.buffers[e].normalBuffer=o,programGCodeInfo.buffers[e].vertexCount=gcode_vertices[e].length/3,await new Promise((e=>setTimeout(e,0)))}createVisibleBuffer()}function createVisibleBuffer(){programGCodeInfo.visibleBuffers=[];let e=0;for(let r=0;r<programGCodeInfo.buffers.length;r++){let t=programGCodeInfo.buffers[r];if(t.lastLayer>=startLayer&&t.firstLayer<=endLayer){let r=0,o=t.vertexCount;t.firstLayer<startLayer&&(r=Math.floor((startLayer-t.firstLayer)/(t.lastLayer-t.firstLayer+1)*t.vertexCount)),t.lastLayer>endLayer&&(o=Math.ceil((endLayer-t.firstLayer+1)/(t.lastLayer-t.firstLayer+1)*t.vertexCount));let a=o-r;programGCodeInfo.visibleBuffers.push({vertexBuffer:t.vertexBuffer,colorBuffer:t.colorBuffer,normalBuffer:t.normalBuffer,startVertex:r,vertexCount:a}),e+=a}}programGCodeInfo.totalVisibleVertices=e}function drawGCode(){if(!checkProgramStatus(programGCodeInfo.program,"programGCode"))return!1;if(!programGCodeInfo.buffers||0===programGCodeInfo.buffers.length)return console.warn("No GCode buffers to draw"),!0;if(useProgram(programGCodeInfo,programGridInfo),gl.uniformMatrix4fv(programGCodeInfo.uniformLocations.pMatrix,!1,new Float32Array(pMatrix)),checkGLError("pMatrix"))return!1;if(gl.uniformMatrix4fv(programGCodeInfo.uniformLocations.mvMatrix,!1,new Float32Array(mvMatrix)),checkGLError("mvMatrix"))return!1;if(invertXY?gl.uniform3fv(programGCodeInfo.uniformLocations.lightPosition,[-2*gridSide,-gridSide,gridSide]):gl.uniform3fv(programGCodeInfo.uniformLocations.lightPosition,[2*gridSide,-gridSide,2*gridSide]),gl.uniform3fv(programGCodeInfo.uniformLocations.ambientColor,[.2,.2,.2]),gl.uniform3fv(programGCodeInfo.uniformLocations.diffuseColor,[.8,.8,.8]),checkGLError("GCode uniforms"))return!1;let e=0;return programGCodeInfo.visibleBuffers.forEach(((r,t)=>{gl.bindBuffer(gl.ARRAY_BUFFER,r.vertexBuffer),gl.vertexAttribPointer(programGCodeInfo.attribLocations.vertexPosition,3,gl.FLOAT,!1,0,12*r.startVertex),gl.bindBuffer(gl.ARRAY_BUFFER,r.normalBuffer),gl.vertexAttribPointer(programGCodeInfo.attribLocations.vertexNormal,3,gl.BYTE,!0,0,3*r.startVertex),gl.bindBuffer(gl.ARRAY_BUFFER,r.colorBuffer),gl.vertexAttribPointer(programGCodeInfo.attribLocations.vertexColor,4,gl.FLOAT,!1,0,16*r.startVertex),gl.drawArrays(gl.TRIANGLES,0,r.vertexCount),e+=r.vertexCount})),isComputing=!1,updateProgress("",100),!0}function updateProgress(e,r=null){const t=document.getElementById("progressBar");t.style.display=null===r||r>0&&r<100?"block":"none",r?(t.style.width=r+"%",t.textContent=e+" "+r.toFixed(1)+"%"):(r=0,t.textContent=e)}function initLayerSliders(){const e=layers.size,r=document.getElementById("startLayerSlider"),t=document.getElementById("endLayerSlider");r.max=e-1,t.max=e-1,t.value=e-1,r.value=0,startLayer=0,endLayer=e-1,updateLayerDisplay()}function updateLayerDisplay(){document.getElementById("startLayerDisplay").textContent=startLayer+1,document.getElementById("endLayerDisplay").textContent=endLayer,document.getElementById("startLayerSlider").value=startLayer,document.getElementById("endLayerSlider").value=endLayer}function autoRotate(e){if(!animationFrameId)return;const r=e-lastFrameTime;lastFrameTime=e;const t=createRotationMatrix(autoRotationSpeed*r,vec3_normalize([mvMatrix[1],mvMatrix[5],mvMatrix[9]])),o=gridSide/2,a=gridSide/2,i=gridSide/2;let n=createTranslationMatrix(-o,-a,-i),s=createTranslationMatrix(o,a,i);mvMatrix=multiplyMatrices(s,mvMatrix),mvMatrix=multiplyMatrices(t,mvMatrix),mvMatrix=multiplyMatrices(n,mvMatrix),cameraPosition=[mvMatrix[12],mvMatrix[13],mvMatrix[14]],drawScene(),requestAnimationFrame(autoRotate)}function animate(e){animationFrameId&&(autoRotate(e),drawScene(),animationFrameId=requestAnimationFrame(animate))}function stopAnimation(){animationFrameId&&(cancelAnimationFrame(animationFrameId),animationFrameId=null),document.getElementById("toggleAutoRotation").checked=!1}function toggleAutoRotation(){animationFrameId?(cancelAnimationFrame(animationFrameId),animationFrameId=null,document.getElementById("toggleAutoRotation").checked=!1):(lastFrameTime=performance.now(),animationFrameId=requestAnimationFrame(animate),document.getElementById("toggleAutoRotation").checked=!0),updateAutoRotationButton()}function updateAutoRotationButton(){document.getElementById("toggleAutoRotation").textContent=animationFrameId?"Stop animation":"Start animation"}async function toggleXYInversion(){invertXY=document.getElementById("invertXY").checked,useProgram(programGridInfo,programGridInfo),updateAxisColors(),createAxisLabelsBuffers(),useProgram(programGCodeInfo,programGridInfo);try{await updateVisiblePoints(!1),setView("front"),drawScene()}catch(e){console.error("Error updating visible points:",e)}}async function toggleFrontBackInversion(){invertFrontBack=document.getElementById("invertFrontBack").checked,useProgram(programGridInfo,programGridInfo),createZLabelBuffer();try{setView("front"),drawScene()}catch(e){console.error("Error updating visible points:",e)}}function handleMouseDown(e){stopAnimation(),isComputing||isFileProcessing?console.warn("Computing is already running, ignoring mouse down event"):(mouseDown=!0,lastMouseX=e.clientX,lastMouseY=e.clientY,startPanX=e.clientX,startPanY=e.clientY,isPanning=2===e.button)}function handleMouseMove(e){if(!mouseDown)return;stopAnimation();const r=e.clientX,t=e.clientY,o=r-lastMouseX,a=t-lastMouseY;isPanning?panScene(o,a):rotateScene(o,a),lastMouseX=r,lastMouseY=t,drawScene()}function handleMouseUp(e){mouseDown=!1,isPanning=!1,lastPinchDistance=0}function rotateScene(e,r){const t=[mvMatrix[0],mvMatrix[4],mvMatrix[8]],o=[mvMatrix[1],mvMatrix[5],mvMatrix[9]],a=vec3_normalize(t),i=createRotationMatrix(.005*-e,vec3_normalize(o)),n=createRotationMatrix(.005*-r,a),s=gridSide/2,l=gridSide/2,c=gridSide/2;let d=createTranslationMatrix(-s,-l,-c),f=createTranslationMatrix(s,l,c);mvMatrix=multiplyMatrices(f,mvMatrix),mvMatrix=multiplyMatrices(i,mvMatrix),mvMatrix=multiplyMatrices(n,mvMatrix),mvMatrix=multiplyMatrices(d,mvMatrix),cameraPosition=[mvMatrix[12],mvMatrix[13],mvMatrix[14]]}function panScene(e,r){mvMatrix[12]+=.5*e,mvMatrix[13]-=.5*r,cameraPosition[0]=mvMatrix[12],cameraPosition[1]=mvMatrix[13]}function handleWheel(e){if(stopAnimation(),e.preventDefault(),isComputing||isFileProcessing)return void console.warn("Computing is already running, ignoring wheel event");const r=e.target.getBoundingClientRect(),t=e.clientX-r.left,o=e.clientY-r.top;let a=Math.sign(e.deltaY);isWheelInverted&&(a=-a);const i=scaleFactor;scaleFactor-=.1*a,scaleFactor=Math.max(minZoom,Math.min(scaleFactor,maxZoom));const n=scaleFactor/i,s=-gridSide/2,l=gcodePoints>0?-gcodeMaxZ/2:-gridSide/2,c=-gridSide/2,d=createTranslationMatrix(-s,-l,-c),f=createTranslationMatrix(s,l,c);if(mvMatrix=multiplyMatrices(f,multiplyMatrices([n,0,0,0,0,n,0,0,0,0,n,0,0,0,0,1],multiplyMatrices(d,mvMatrix))),isSmartZoomEnabled){const e=t/gl.canvas.width*2-1,r=1-o/gl.canvas.height*2,a=e*(1-n)*mvMatrix[14],i=r*(1-n)*mvMatrix[14];mvMatrix[12]+=a,mvMatrix[13]+=i}cameraPosition=[mvMatrix[12],mvMatrix[13],mvMatrix[14]],currentCameraDistance=initialCameraDistance*scaleFactor;getSkipFactor(i,layers.size)!==getSkipFactor(scaleFactor,layers.size)?updateVisiblePoints(!1).then((()=>{drawScene()})).catch((e=>{console.error("Error updating visible points:",e)})):drawScene()}function handleTouchStart(e){e.preventDefault(),stopAnimation(),1===e.touches.length?handleMouseDown(e.touches[0]):2===e.touches.length&&(isPanning=!0,handleMouseDown(e.touches[0]))}function handleTouchMove(e){if(e.preventDefault(),stopAnimation(),1===e.touches.length)handleMouseMove(e.touches[0]);else if(2===e.touches.length){const r=e.touches[0],t=e.touches[1];handlePinchZoom(Math.hypot(r.pageX-t.pageX,r.pageY-t.pageY))}}function handleTouchEnd(e){handleMouseUp(e)}function handlePinchZoom(e){if(stopAnimation(),0===lastPinchDistance)return void(lastPinchDistance=e);handleWheel({preventDefault:()=>{},deltaY:lastPinchDistance-e,clientX:0,clientY:0,target:gl.canvas}),lastPinchDistance=e}function resizeCanvas(){stopAnimation();const e=document.getElementById("glCanvas"),r=document.getElementById("controls"),t=document.getElementById("container"),o=window.innerWidth,a=window.innerHeight,i=Math.min(o,a)-20;let n,s,l;o>a?(n=Math.min(i,a-20),l=n,t.style.flexDirection="row"):(n=Math.min(i,o-20),s=n,l=Math.max(200,a-n),t.style.flexDirection="column"),e.width=e.height=n,r.style.width=`${s}px`,r.style.height=`${l}px`,drawScene()}function formatFileSize(e){if(0===e)return"0 Bytes";const r=Math.floor(Math.log(e)/Math.log(1024));return parseFloat((e/Math.pow(1024,r)).toFixed(2))+" "+["Bytes","KB","MB","GB"][r]}function init(){const e=document.getElementById("glCanvas");if(initWebGL(e),gl){if(initCamera(),!createShaders())return void console.error("Impossible to initialize the shaders");if(!createGridBuffers())return void console.error("Impossible to initialize the grid buffers");if(["front","back","left","right","top","bottom"].forEach((e=>{document.getElementById(`${e}View`).addEventListener("click",(()=>{setView(e),drawScene()}))})),setView("front"),window.addEventListener("resize",resizeCanvas),resizeCanvas(),!drawScene())return void console.error("Impossible to draw the scene");e.onmousedown=handleMouseDown,document.onmouseup=handleMouseUp,document.onmousemove=handleMouseMove,e.addEventListener("wheel",handleWheel,{passive:!1}),e.oncontextmenu=e=>e.preventDefault(),e.addEventListener("touchstart",handleTouchStart,{passive:!1}),e.addEventListener("touchmove",handleTouchMove,{passive:!1}),e.addEventListener("touchend",handleTouchEnd),document.getElementById("toggleNonExtrusion").addEventListener("change",(async function(){if(isComputing||isFileProcessing)this.checked=!this.checked;else if(stopAnimation(),0!==gcodePoints.length){showNonExtrusionMoves=!this.checked;try{startLayer=0,endLayer=layers.size-1,updateLayerDisplay(),await updateVisiblePoints(!1),drawScene()}catch(e){console.error("Error updating visible points:",e)}}})),document.getElementById("toggleNonExtrusion").checked=!showNonExtrusionMoves;const r=document.getElementById("fileInput"),t=document.getElementById("uploadButton"),o=document.getElementById("fileName"),a=document.getElementById("fileSize");t.addEventListener("click",(function(){r.click()})),r.addEventListener("change",(function(e){if(isComputing||isFileProcessing)return;stopAnimation(),gcodePoints=[],visiblePoints=[],setView("front"),drawScene();let r=e.target.files[0];r&&(o.textContent=r.name,a.textContent=formatFileSize(r.size),loadGCodeFile(r))})),document.getElementById("startLayerSlider").addEventListener("input",(function(){isComputing||isFileProcessing||(stopAnimation(),0!==gcodePoints.length&&(startLayer=parseInt(this.value),startLayer>endLayer&&(endLayer=startLayer,document.getElementById("endLayerSlider").value=endLayer),updateLayerDisplay(),debouncedUpdateAndRedraw()))})),document.getElementById("endLayerSlider").addEventListener("input",(function(){isComputing||isFileProcessing||(stopAnimation(),0!==gcodePoints.length&&(endLayer=parseInt(this.value),endLayer<startLayer&&(startLayer=endLayer,document.getElementById("startLayerSlider").value=startLayer),updateLayerDisplay(),debouncedUpdateAndRedraw()))})),document.getElementById("toggleAutoRotation").addEventListener("change",(function(){isComputing||isFileProcessing?this.checked=!this.checked:toggleAutoRotation()})),document.getElementById("invertXY").addEventListener("change",(async function(){if(isComputing||isFileProcessing)this.checked=!this.checked;else{stopAnimation();try{startLayer=0,endLayer=layers.size-1,updateLayerDisplay(),await toggleXYInversion()}catch(e){console.error("Error toggling XY inversion:",e)}}})),document.getElementById("invertFrontBack").addEventListener("change",(async function(){if(isComputing||isFileProcessing)this.checked=!this.checked;else{stopAnimation();try{await toggleFrontBackInversion()}catch(e){console.error("Error toggling Front/Back inversion:",e)}}})),document.getElementById("smartZoomToggle").addEventListener("change",(function(e){isSmartZoomEnabled=e.target.checked})),isSmartZoomEnabled&&(document.getElementById("smartZoomToggle").checked=!0),document.getElementById("wheelInvertToggle").addEventListener("change",(function(e){isWheelInverted=e.target.checked})),isWheelInverted&&(document.getElementById("wheelInvertToggle").checked=!0)}}window.onload=init</script><script id="grid-vertex-shader" type="x-shader/x-vertex">attribute vec3 grid_aVertexPosition;
    attribute vec4 grid_aVertexColor;
    uniform mat4 grid_uMVMatrix;
    uniform mat4 grid_uPMatrix;
    varying vec4 grid_vColor;
    void main(void) {
        gl_Position = grid_uPMatrix * grid_uMVMatrix * vec4(grid_aVertexPosition, 1.0);
        grid_vColor = grid_aVertexColor;
    }</script><script id="fragment-shader-grid" type="x-shader/x-fragment">precision mediump float;
    varying vec4 grid_vColor;
    void main(void) {
        gl_FragColor = grid_vColor;
    }</script><antartifact identifier="lambert-shaders" type="application/vnd.ant.code" language="html" title="Définitions des shaders Lambert"></antartifact><script id="gcode-vertex-shader" type="x-shader/x-vertex">attribute vec3 gcode_aVertexPosition;
    attribute vec3 gcode_aVertexNormal;
    attribute vec4 gcode_aVertexColor;

    uniform mat4 gcode_uMVMatrix;
    uniform mat4 gcode_uPMatrix;
    uniform vec3 gcode_uLightPosition;

    varying vec3 vNormal;
    varying vec3 vLightRay;
    varying vec4 vColor;

    void main(void) {
        vec4 vertex = gcode_uMVMatrix * vec4(gcode_aVertexPosition, 1.0);
        gl_Position = gcode_uPMatrix * vertex;

        vNormal = mat3(gcode_uMVMatrix) * gcode_aVertexNormal;
        vLightRay = gcode_uLightPosition - vertex.xyz;
        vColor = gcode_aVertexColor;
    }</script><script id="fragment-shader-gcode" type="x-shader/x-fragment">precision mediump float;

    varying vec3 vNormal;
    varying vec3 vLightRay;
    varying vec4 vColor;

    uniform vec3 gcode_uAmbientColor;
    uniform vec3 gcode_uDiffuseColor;

    void main(void) {
        vec3 L = normalize(vLightRay);
        vec3 N = normalize(vNormal);

        float lambertTerm = max(dot(N, L), 0.0);

        vec3 finalColor = gcode_uAmbientColor + lambertTerm * gcode_uDiffuseColor;

        gl_FragColor = vec4(finalColor * vColor.rgb, vColor.a);
    }</script><style>body,html{margin:0;padding:0;width:100%;height:100%;display:flex;justify-content:center;align-items:center}#extensionUI-container{display:flex;flex-direction:column;justify-content:center;align-items:center;width:100%;height:100%;padding:20px;box-sizing:border-box}#glCanvas{margin:10px;padding:0}</style><div id="extensionUI-container"><canvas id="glCanvas" width="4001" height="400"></canvas><div id="controls" style="overflow-y:auto"><div id="progressBar" style="width:0%;height:30px;background-color:#4caf50;text-align:center;line-height:30px;color:#fff">0%</div><div><input type="checkbox" id="toggleNonExtrusion"> <label for="toggleNonExtrusion">Hide travel moves</label></div><div><input type="checkbox" id="toggleAutoRotation"> <label for="toggleAutoRotation">Animate</label></div><div><input type="checkbox" id="invertXY"> <label for="invertXY">Invert X/Y</label></div><div><input type="checkbox" id="invertFrontBack"> <label for="invertFrontBack">Invert Front/Back</label></div><div><input type="checkbox" id="smartZoomToggle"> <label for="smartZoomToggle">Enable Smart Zoom</label></div><div><input type="checkbox" id="wheelInvertToggle"> <label for="wheelInvertToggle">Invert Wheel Direction</label></div><div id="viewControls"><button id="frontView">Front</button> <button id="backView">Back</button> <button id="leftView">Left</button> <button id="rightView">Right</button> <button id="topView">Top</button> <button id="bottomView">Bottom</button></div><div><label for="startLayerSlider">Start layer:</label> <input type="range" id="startLayerSlider" min="0" max="100" value="0"> <span id="startLayerDisplay">0</span></div><div><label for="endLayerSlider">End layer:</label> <input type="range" id="endLayerSlider" min="0" max="100" value="100"> <span id="endLayerDisplay">100</span></div><div id="fileUploadContainer"><input type="file" id="fileInput" accept=".gcode" style="display:none"> <button id="uploadButton">Upload</button> <span id="fileName"></span> <span id="fileSize"></span></div></div></div>